{"version":3,"sources":["knockout-decorator.ts"],"names":["require","exports","KnockoutDecorator","track","arg","constructor","isIgnore","propertyName","ignoresKey","indexOf","trackConstructor","apply","this","arguments","o","properties","Object","keys","forEach","p","storeObservableKey","v","Array","isArray","observableArray","prototype","observable","functions","computedAccessors","f","d","getOwnPropertyDescriptor","get","getComputed","getComputedDecoratorFactory","pure","options","pureComputed","defineProperty","push","a","initializeMethod","defaults","key","undefined","classFactory","ignore","_class","registerProperty","instancedObj","ko","set","getSetter","value","replaceFunction","src","originals","fnName","mimicry","res","arrayValue","mergeFunction","computed","length","descriptor","extend","registerExtend","setFilter","filterFunc","registerSetFilter","parseFloat","isNaN","min","minValue","max","maxValue","clamp","tmp","getObservable","getObservableObject","isObservable","getObservableArray","c","isComputed","setObservableObjet","store","computedOptions","read","getter","write","setter","fn_1","extendOptions","storeExtendKey","getExtend","storeSetFilterKey","filters","len","i","assignExtendForInstancedObj","ext","module"],"mappings":"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","file":"knockout-decorator.min.js","sourcesContent":["/*!\r\n * Knockout decorator\r\n * (c) vario\r\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\r\n */\r\n\r\n\r\nmodule KnockoutDecorator\r\n{\r\n\t// #region declare interfaces.\r\n\t/**\r\n\t * You can easily access KnockoubObservableArray functions via intellisense\r\n\t * by converting a array property which is attaching @observableArray.\r\n\t */\r\n\texport interface IObservableArray<T> extends Array<T>\r\n\t{\r\n\t\t/** Execute KnockoutObservableArray.replace */\r\n\t\treplace( oldItem: T, newItem: T ): void;\r\n\r\n\t\t/** Execute KnockoutObservableArray.remove */\r\n\t\tremove( item: T ): T[];\r\n\r\n\t\t/** Execute KnockoutObservableArray.remove */\r\n\t\tremove( removeFunction: ( item: T ) => boolean ): T[];\r\n\r\n\t\t/** Execute KnockoutObservableArray.removeAll */\r\n\t\tremoveAll( items: T[] ): T[];\r\n\r\n\t\t/** Execute KnockoutObservableArray.removeAll */\r\n\t\tremoveAll(): T[];\r\n\r\n\t\t/** Execute KnockoutObservableArray.destroy */\r\n\t\tdestroy( item: T ): void;\r\n\r\n\t\t/** Execute KnockoutObservableArray.destroy */\r\n\t\tdestroy( destroyFunction: ( item: T ) => boolean ): void;\r\n\r\n\t\t/** Execute KnockoutObservableArray.destroyAll */\r\n\t\tdestroyAll( items: T[] ): void;\r\n\r\n\t\t/** Execute KnockoutObservableArray.destroyAll */\r\n\t\tdestroyAll(): void;\r\n\t}\r\n\r\n\t/**\r\n\t * @computed argument options.\r\n\t */\r\n\texport interface IComputedOptions\r\n\t{\r\n\t\tpure?: boolean;\r\n\t\tdeferEvaluation?: boolean;\r\n\t\tdisposeWhen?(): boolean;\r\n\t\tdisposeWhenNodeIsRemoved?: Node;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t/**\r\n\t * Argument of @track decorator.\r\n\t */\r\n\texport interface ITrackOptions\r\n\t{\r\n\t\t/**\r\n\t\t * Convert to pure computed if true or undefined, non pure computed otherwise.\r\n\t\t */\r\n\t\tpureComputed?: boolean,\r\n\r\n\t\t/**\r\n\t\t * Set name of method that you want to execute after a constructor finish.\r\n\t\t * You can get raw observable objects using getObservable<T>() in the method.\r\n\t\t * Attension; when you use `@track` decorator, you can't get raw observable in a constructor.\r\n\t\t */\r\n\t\tinitializeMethod?: string,\r\n\r\n\r\n\t\t[key: string]: any\r\n\t}\r\n\t/**\r\n\t * Attach to a class as decorator.\r\n\t * This decorator converts all properties and accessors to observable.\r\n\t * Points to consider.\r\n\t * 1. Have to initialize properties at place of declaration or in constructor to be recognized as observable.(set `null` is OK also)\r\n\t * 2. Have to set array value for array properties to be recognized as oservable array.\r\n\t *    If you first set null to a array property, the property will recognize as KnockoutObservable&lt;T[]>, not KnockoutObservableArray&lt;T>.\r\n\t * 3. Accessors will be converted to pure computed.\r\n\t *    If you want to use non pure computed, pass { pureComputed:true } to `@track`\r\n\t *    or attach `@computed` decorator to accessors.\r\n\t * 4. If you want to prevent properties or accessors from converting to observable,\r\n\t *    attach `@ignore` decorator to them.\r\n\t * 5. You can't get raw observable objects in a constructor.\r\n\t */\r\n\texport function track( constructor: Function ): any;\r\n\t/**\r\n\t * Attach to a class as decorator.\r\n\t * This decorator converts all properties and accessors to observable.\r\n\t * Points to consider.\r\n\t * 1. Have to initialize properties at place of declaration or in constructor to be recognized as observable.(set `null` is OK also)\r\n\t * 2. Have to set array value for array properties to be recognized as oservable array.\r\n\t *    If you first set null to a array property, the property will recognize as KnockoutObservable<T[]>, not KnockoutObservableArray<T>.\r\n\t * 3. Accessors will be converted to pure computed.\r\n\t *    If you want to use non pure computed, pass { pureComputed:true } to `@track`\r\n\t *    or attach `@computed` decorator to accessors.\r\n\t * 4. If you want to prevent properties or accessors from converting to observable,\r\n\t *    attach `@ignore` decorator to them.\r\n\t * 5. You can't get raw observable objects in a constructor.\r\n\t */\r\n\texport function track( options: ITrackOptions ): any;\r\n\texport function track( arg:any ) : any\r\n\t{\r\n\t\tlet options: ITrackOptions;\r\n\t\tif ( typeof arg === \"function\" )\r\n\t\t{\r\n\t\t\toptions = {\r\n\t\t\t\tpureComputed: true,\r\n\t\t\t\tinitializeMethod: null\r\n\t\t\t};\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\toptions = arg;\r\n\t\t\tlet defaults = {\r\n\t\t\t\tpureComputed: true,\r\n\t\t\t\tinitializeMethod: null\r\n\t\t\t} as ITrackOptions;\r\n\t\t\tif ( !options )\r\n\t\t\t{\r\n\t\t\t\toptions = defaults;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tfor ( let key in defaults )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( options[key] === undefined )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toptions[key] = defaults[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction classFactory( constructor: Function )\r\n\t\t{\r\n\t\t\tlet isIgnore = ( propertyName: string ) =>\r\n\t\t\t{\r\n\t\t\t\tif ( !(<any>constructor)[ignoresKey] ) return false;\r\n\t\t\t\t//console.log( \"ig check\", propertyName );\r\n\t\t\t\treturn (<any>constructor)[ignoresKey].indexOf( propertyName ) >= 0;\r\n\t\t\t}\r\n\r\n\t\t\tlet trackConstructor: any = function ()\r\n\t\t\t{\r\n\t\t\t\tconstructor.apply( this, arguments );\r\n\t\t\t\tlet o = this;\r\n\r\n\t\t\t\tlet properties = Object.keys( o );\r\n\t\t\t\tproperties.forEach( p =>\r\n\t\t\t\t{\r\n\t\t\t\t\t//console.log( \"p is\", p );\r\n\t\t\t\t\tif ( p === storeObservableKey ) return;\r\n\t\t\t\t\tif ( isIgnore( p ) ) return;\r\n\r\n\t\t\t\t\t//console.log( \"assign observable\", p );\r\n\r\n\t\t\t\t\tlet v = o[p];\r\n\t\t\t\t\tdelete o[p];\r\n\t\t\t\t\tif ( Array.isArray( v ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tobservableArray( trackConstructor.prototype, p );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tobservable( trackConstructor.prototype, p );\r\n\t\t\t\t\t}\r\n\t\t\t\t\to[p] = v;\r\n\t\t\t\t});\r\n\r\n\t\t\t\tlet functions = Object.keys( constructor.prototype );\r\n\t\t\t\t//console.log( functions );\r\n\t\t\t\tlet computedAccessors : any[] = [];\r\n\t\t\t\tfunctions.forEach( f =>\r\n\t\t\t\t{\r\n\r\n\t\t\t\t\t//console.log( \"f is\", f );\r\n\t\t\t\t\tlet d = Object.getOwnPropertyDescriptor( constructor.prototype, f );\r\n\t\t\t\t\tif ( !d || !d.get ) return;\r\n\t\t\t\t\tif ( isIgnore( f ) ) return;\r\n\t\t\t\t\tlet dummy = o[f];\r\n\t\t\t\t\tif ( getComputed( o, f ) ) return;\r\n\r\n\t\t\t\t\t//console.log( \"f is \", f, d.get );\r\n\t\t\t\t\t//console.log( \"f\", f, f[\"name\"] );\r\n\t\t\t\t\t//return;\r\n\t\t\t\t\t/*if ( isRegisteredObserbable( c.prototype, f ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcomputedAccessors.push( f );\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}*/\r\n\t\t\t\t\t\r\n\t\t\t\t\tlet factory = getComputedDecoratorFactory( {\r\n\t\t\t\t\t\tpure: options.pureComputed\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tfactory( trackConstructor.prototype, f, d );\r\n\t\t\t\t\tObject.defineProperty( trackConstructor.prototype, f, d );\r\n\t\t\t\t\tcomputedAccessors.push( f );\r\n\t\t\t\t\t//co = getComputed( o, f );\r\n\t\t\t\t\t//console.log( \"f is 2 \", dummy, co );\r\n\t\t\t\t});\r\n\t\t\t\t\r\n\t\t\t\tcomputedAccessors.forEach( a => o[a] );\r\n\t\t\t\tcomputedAccessors = null;\r\n\t\t\t\tfunctions = null;\r\n\t\t\t\tproperties = null;\r\n\t\t\t\tif ( options.initializeMethod && typeof o[options.initializeMethod] === \"function\" )\r\n\t\t\t\t{\r\n\t\t\t\t\to[options.initializeMethod]();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttrackConstructor[\"prototype\"] = constructor[\"prototype\"];\r\n\t\t\treturn trackConstructor;\r\n\t\t}\r\n\t\t\r\n\t\tif ( typeof arg === \"function\" )\r\n\t\t{\r\n\t\t\treturn classFactory( arg );\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn function ( constructor: Function )\r\n\t\t\t{\r\n\t\t\t\treturn classFactory( constructor );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/** @private */\r\n\tconst ignoresKey = \"__vtKnockoutIgnoresKey__\";\r\n\r\n\t/**\r\n\t * Attach to a property or a accessor as decorator.\r\n\t * This decorator prevents a property or a accessor from converting to observable in @track.\r\n\t */\r\n\texport function ignore( _class: any, propertyName: string ): void\r\n\t{\r\n\t\tlet constructor = _class.constructor;\r\n\t\tif ( !constructor[ignoresKey] ) constructor[ignoresKey] = [];\r\n\t\tconstructor[ignoresKey].push( propertyName );\r\n\t}\r\n\r\n\t/**\r\n\t * Attach to a property as decorator.\r\n\t * If you change a property value, a view will also change. And vice versa.\r\n\t */\r\n\texport function observable( _class: any, propertyName: string ): void\r\n\t{\r\n\t\t//if ( isRegisteredObserbable( _class, propertyName ) ) return;\r\n\t\t//setRegisterObserbable( _class, propertyName );\r\n\t\tfunction registerProperty( instancedObj: any ): void\r\n\t\t{\r\n\t\t\tlet o = ko.observable();\r\n\t\t\tsetObservableObjet( instancedObj, propertyName, o );\r\n\t\t\tassignExtendForInstancedObj( _class, instancedObj, propertyName );\r\n\t\t\tObject.defineProperty( instancedObj, propertyName, {\r\n\t\t\t\tget: o,\r\n\t\t\t\tset: getSetter( _class, propertyName, o )\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tObject.defineProperty( _class, propertyName, {\r\n\t\t\tget: function (): any\r\n\t\t\t{\r\n\t\t\t\tregisterProperty( this );\r\n\t\t\t\treturn this[propertyName];\r\n\t\t\t},\r\n\t\t\tset: function ( value: any ): void\r\n\t\t\t{\r\n\t\t\t\tregisterProperty( this );\r\n\t\t\t\tthis[propertyName] = value;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Attach to a array property as decorator.\r\n\t * If you set a property to a new array data, a view will also change.\r\n\t * If you call a Array function such as push or pop, a view will also change.\r\n\t */\r\n\texport function observableArray( _class: any, propertyName: string ): void\r\n\t{\r\n\t\t//if ( isRegisteredObserbable( _class, propertyName ) ) return;\r\n\t\t//setRegisterObserbable( _class, propertyName );\r\n\t\tfunction replaceFunction( src: any[], o: KnockoutObservableArray<any> )\r\n\t\t{\r\n\t\t\tlet originals: { [fn: string]: Function } = {};\r\n\t\t\t[\"splice\", \"pop\", \"push\", \"shift\", \"unshift\", \"reverse\", \"sort\"].forEach( fnName =>\r\n\t\t\t{\r\n\t\t\t\toriginals[fnName] = (<any>src)[fnName];\r\n\t\t\t\tlet mimicry = function ()\r\n\t\t\t\t{\r\n\t\t\t\t\t// restore the original function for call it inside ObservableArray.\r\n\t\t\t\t\t(<any>src)[fnName] = originals[fnName];\r\n\r\n\t\t\t\t\t// call ObservableArray function\r\n\t\t\t\t\tlet res = ( o[fnName] as Function ).apply( o, arguments );\r\n\r\n\t\t\t\t\t// rewrite the original function again.\r\n\t\t\t\t\t(<any>src)[fnName] = mimicry;\r\n\r\n\t\t\t\t\treturn res;\r\n\t\t\t\t};\r\n\r\n\t\t\t\t// rewrite the original function\r\n\t\t\t\t(<any>src)[fnName] = mimicry;\r\n\t\t\t});\r\n\t\t}\r\n\t\tfunction mergeFunction( src: any[], o: KnockoutObservableArray<any>  )\r\n\t\t{\r\n\t\t\t[\"replace\", \"remove\", \"removeAll\", \"destroy\", \"destroyAll\"].forEach( fnName =>\r\n\t\t\t{\r\n\t\t\t\t(<any>src)[fnName] = function ()\r\n\t\t\t\t{\r\n\t\t\t\t\treturn ( o[fnName] as Function ).apply( o, arguments );\r\n\t\t\t\t};\r\n\t\t\t});\r\n\t\t}\r\n\t\tfunction registerProperty( instancedObj: any ): void\r\n\t\t{\r\n\t\t\tlet o = ko.observableArray();\r\n\t\t\tsetObservableObjet( instancedObj, propertyName, o );\r\n\t\t\tassignExtendForInstancedObj( _class, instancedObj, propertyName );\r\n\t\t\tObject.defineProperty( instancedObj, propertyName, {\r\n\t\t\t\tget: o,\r\n\t\t\t\tset: function ( arrayValue: any[] )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( arrayValue )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treplaceFunction( arrayValue, o );\r\n\t\t\t\t\t\tmergeFunction( arrayValue, o );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tgetSetter( _class, propertyName, o )( arrayValue );\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t}\r\n\r\n\t\tObject.defineProperty( _class, propertyName, {\r\n\t\t\tget: function (): any[]\r\n\t\t\t{\r\n\t\t\t\tregisterProperty( this );\r\n\t\t\t\treturn this[propertyName];\r\n\t\t\t},\r\n\t\t\tset: function ( arrayValue: any ): void\r\n\t\t\t{\r\n\t\t\t\tregisterProperty( this );\r\n\t\t\t\tthis[propertyName] = arrayValue;\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Attach to a accessor as decorator.\r\n\t * If a observable property value in a getter is changed, the getter will be executed.\r\n\t * If you define also a setter, you can handle as writable computed.\r\n\t */\r\n\texport function computed( _class: any, propertyName: string, descriptor: PropertyDescriptor ): void\r\n\t/**\r\n\t * Attach to a accessor as decorator.\r\n\t * @param options\tKnockout computed options.\r\n\t * @see <a href=\"http://knockoutjs.com/documentation/computed-reference.html\" target=\"_blank\">Computed Observable Reference</a>\r\n\t */\r\n\texport function computed( options: IComputedOptions ): MethodDecorator;\r\n\texport function computed(): any\r\n\t{\r\n\t\tif ( arguments.length == 1 )\r\n\t\t{\r\n\t\t\treturn getComputedDecoratorFactory( arguments[0] );\r\n\t\t}\r\n\t\tgetComputedDecoratorFactory( null ).apply( this, arguments );\r\n\t}\r\n\r\n\t/**\r\n\t * Attach to a accessor as decorator.\r\n\t */\r\n\texport function pureComputed( _class: any, propertyName: string, descriptor: PropertyDescriptor ): void\r\n\t{\r\n\t\tgetComputedDecoratorFactory( { pure: true } )( _class, propertyName, descriptor );\r\n\t}\r\n\r\n\t/**\r\n\t * Attach to a property or accessor.\r\n\t * @extend require attaching observable decorator.\r\n\t * @param options\tSet parameter which define ko.extenders such as rateLimit.\r\n\t */\r\n\texport function extend( options: { [key: string]: any }): any// PropertyDecorator | MethodDecorator\r\n\t{\r\n\t\treturn ( _class: any, propertyName: string, descriptor?: PropertyDescriptor ) =>\r\n\t\t{\r\n\t\t\tregisterExtend( _class, propertyName, options );\r\n\t\t};\r\n\t}\r\n\r\n\t//#region set filter decorators\r\n\t/**\r\n\t * Attach to a property or accessor(setter).\r\n\t * When you set a value to a property or a setter, the value will be changed through filters.\r\n\t * If there is more than one filter, filters are executed in the order from bottom to top.\r\n\t * @param filterFunc function that return a processed value.\r\n\t */\r\n\texport function setFilter( filterFunc: ( setValue: any ) => any ): any // PropertyDecorator | MethodDecorator\r\n\t{\r\n\t\treturn ( _class: any, propertyName: string ) =>\r\n\t\t{\r\n\t\t\tregisterSetFilter( _class, propertyName, filterFunc );\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Attach to a number type property or a accessor(setter).\r\n\t * This decorator is a kind of `@setFilter`.\r\n\t * This decorator converts to number type if set a value other than number type such as value is changed via input element on a browser.\r\n\t * If a converted value is NaN, it handles as zero.\r\n\t * @extend require attaching observable decorator.\r\n\t */\r\n\texport function asNumber( _class: any, propertyName: string ):void\r\n\t{\r\n\t\tregisterSetFilter( _class, propertyName, v =>\r\n\t\t{\r\n\t\t\tif ( !v || typeof v === \"number\" ) return v;\r\n\t\t\tv = parseFloat( v );\r\n\t\t\treturn isNaN( v ) ? 0 : v;\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Attach to a number type property or a accessor(setter).\r\n\t * This decorator is a kind of `@setFilter`.\r\n\t * This decorator keeps greater than or equal to minValue.\r\n\t * @extend require attaching observable decorator.\r\n\t */\r\n\texport function min( minValue: number ): any // PropertyDecorator | MethodDecorator\r\n\t{\r\n\t\treturn setFilter( v => v < minValue ? minValue : v );\r\n\t}\r\n\r\n\t/**\r\n\t * Attach to a number type property or a accessor(setter).\r\n\t * This decorator is a kind of `@setFilter`.\r\n\t * This decorator keeps less than or equal to maxValue.\r\n\t * @extend require attaching observable decorator.\r\n\t */\r\n\texport function max( maxValue: number ): any // PropertyDecorator | MethodDecorator\r\n\t{\r\n\t\treturn setFilter( v => v > maxValue ? maxValue : v );\r\n\t}\r\n\r\n\t/**\r\n\t * Attach to a number type property or a accessor(setter).\r\n\t * This decorator is a kind of `@setFilter`.\r\n\t * This decorator keeps between minValue and maxValue inclusive.\r\n\t * @extend require attaching observable decorator.\r\n\t */\r\n\texport function clamp( minValue:number, maxValue: number ): any // PropertyDecorator | MethodDecorator\r\n\t{\r\n\t\tif ( minValue > maxValue )\r\n\t\t{\r\n\t\t\tlet tmp = minValue;\r\n\t\t\tminValue = maxValue;\r\n\t\t\tmaxValue = tmp;\r\n\t\t}\r\n\t\treturn setFilter( v =>\r\n\t\t{\r\n\t\t\tif ( v < minValue ) v = minValue;\r\n\t\t\telse if ( v > maxValue ) v = maxValue;\r\n\t\t\treturn v;\r\n\t\t});\r\n\t}\r\n\r\n\t//#endregion\r\n\r\n\t/**\r\n\t * Get raw knockout observable object.\r\n\t * @param instancedObj\tInstanced object.\r\n\t * @param propertyName\t\tName of a property which is attached the @observable.\r\n\t * @return If found then KnockoutObservable object, else null.\r\n\t */\r\n\texport function getObservable<T>( instancedObj: any, propertyName: string ): KnockoutObservable<T>\r\n\t{\r\n\t\tlet o = getObservableObject( instancedObj, propertyName );\r\n\t\treturn ( ko.isObservable( o ) && o.indexOf === undefined ) ? o : null;\r\n\t}\r\n\r\n\t/**\r\n\t * Get row knockout observable array object.\r\n\t * @param instancedObj\tInstanced object.\r\n\t * @param propertyName\t\tName of a property which is attached the @observableArray.\r\n\t */\r\n\texport function getObservableArray<T>( instancedObj: any, propertyName: string ): KnockoutObservableArray<T>\r\n\t{\r\n\t\tlet o = getObservableObject(instancedObj, propertyName);\r\n\t\tlet res = (ko.isObservable(o) && o.indexOf !== undefined) ? o : null;\r\n\t\treturn res as KnockoutObservableArray<T>;\r\n\t}\r\n\r\n\t/**\r\n\t * Get raw knockout computed object.\r\n\t * @param instancedObj\tInstanced object.\r\n\t * @param propertyName\t\tName of a property which is attached the @computed.\r\n\t * @return If found then KnockoutComputed object, else null.\r\n\t */\r\n\texport function getComputed<T>( instancedObj: any, propertyName: string ): KnockoutComputed<T>\r\n\t{\r\n\t\tlet c = getObservableObject( instancedObj, propertyName );\r\n\t\treturn ko.isComputed( c ) ? c : null;\r\n\t}\r\n\r\n\t// #region no export\r\n\r\n\t/** @private */\r\n\tconst storeObservableKey = \"__vtKnockoutObservables__\";\r\n\r\n\t/** @private */\r\n\tfunction setObservableObjet( instancedObj: any, propertyName: string, o: KnockoutObservable<any> | KnockoutObservableArray<any> | KnockoutComputed<any> )\r\n\t{\r\n\t\tif ( !instancedObj[storeObservableKey] ) instancedObj[storeObservableKey] = {};\r\n\t\tinstancedObj[storeObservableKey][propertyName] = o;\r\n\t}\r\n\r\n\t/** @private */\r\n\tfunction getObservableObject( instancedObj: any, propertyName: string ): any\r\n\t{\r\n\t\tlet store = instancedObj[storeObservableKey];\r\n\t\tif ( !store ) return null;\r\n\t\treturn store[propertyName];\r\n\t}\r\n\r\n\r\n\t/** @private */\r\n\tfunction getComputedDecoratorFactory( options: IComputedOptions ): MethodDecorator\r\n\t{\r\n\t\treturn ( _class: Object, propertyName: string, descriptor: PropertyDescriptor ) =>\r\n\t\t{\r\n\t\t\t//if ( isRegisteredObserbable( _class, propertyName ) ) return;\r\n\t\t\t//setRegisterObserbable( _class, propertyName );\r\n\r\n\t\t\tlet getter = descriptor.get;\r\n\t\t\tif ( !getter )\r\n\t\t\t{\r\n\t\t\t\tthrow \"@Computed and @pureComputed require getter.\";\r\n\t\t\t}\r\n\t\t\tlet setter = descriptor.set;\r\n\r\n\t\t\tfunction registerProperty( instancedObj: any ): void\r\n\t\t\t{\r\n\t\t\t\t//console.log( \"register property computed\", instancedObj, propertyName );\r\n\t\t\t\tlet computedOptions: KnockoutComputedDefine<any> = {\r\n\t\t\t\t\tread: getter,\r\n\t\t\t\t\twrite: setter,\r\n\t\t\t\t\towner: instancedObj\r\n\t\t\t\t};\r\n\t\t\t\tif ( options )\r\n\t\t\t\t{\r\n\t\t\t\t\tfor ( let key in options )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tif ( typeof (<any>options)[key] === \"function\" )\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\tlet fn = (<any>options)[key];\r\n\t\t\t\t\t\t\t(<any>options)[key] = function ()\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tfn.apply( instancedObj, arguments );\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\t(<any>computedOptions)[key] = (<any>options)[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tlet c = ko.computed( computedOptions );\r\n\t\t\t\tsetObservableObjet( instancedObj, propertyName, c );\r\n\t\t\t\tassignExtendForInstancedObj( _class, instancedObj, propertyName );\r\n\r\n\t\t\t\tObject.defineProperty( instancedObj, propertyName, {\r\n\t\t\t\t\tget: c,\r\n\t\t\t\t\tset: setter ? getSetter( _class, propertyName, c ) : undefined\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\r\n\t\t\tdescriptor.get = function()\r\n\t\t\t{\r\n\t\t\t\tregisterProperty( this );\r\n\t\t\t\treturn this[propertyName];\r\n\t\t\t}\r\n\t\t\tif ( setter )\r\n\t\t\t{\r\n\t\t\t\tdescriptor.set = function ( value )\r\n\t\t\t\t{\r\n\t\t\t\t\tregisterProperty( this );\r\n\t\t\t\t\tthis[propertyName] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\t/** @private */\r\n\t//const registerObjserbablesKey = \"__vtKnockoutRegisterObserbables__\";\r\n\r\n\t/** @private */\r\n\t/*function isRegisteredObserbable( _class: any, propertyName: string ): boolean\r\n\t{\r\n\t\treturn _class[registerObjserbablesKey] && _class[registerObjserbablesKey].indexOf( propertyName ) >= 0\r\n\t}*/\r\n\r\n\t/** @private */\r\n\t/*function setRegisterObserbable( _class: any, propertyName: string ): void\r\n\t{\r\n\t\tif ( !_class[registerObjserbablesKey] )\r\n\t\t{\r\n\t\t\t_class[registerObjserbablesKey] = [];\r\n\t\t}\r\n\t\t_class[registerObjserbablesKey].push( propertyName );\r\n\t}*/\r\n\r\n\t/** @private */\r\n\tconst storeExtendKey = \"__vtKnockoutExtends__\";\r\n\r\n\t/** @private */\r\n\tfunction registerExtend( _class: any, propertyName: string, extendOptions: any )\r\n\t{\r\n\t\tif ( !_class[storeExtendKey] ) _class[storeExtendKey] = {};\r\n\t\t_class[storeExtendKey][propertyName] = extendOptions;\r\n\t}\r\n\r\n\t/** @private */\r\n\tfunction getExtend( _class: any, propertyName: string ): any\r\n\t{\r\n\t\tlet store = _class[storeExtendKey];\r\n\t\tif ( !store ) return null;\r\n\t\treturn store[propertyName];\r\n\t}\r\n\r\n\t/** @private */\r\n\tconst storeSetFilterKey = \"__vtKnockoutSetFilters__\";\r\n\r\n\t/** @private */\r\n\tfunction registerSetFilter( _class: any, propertyName: string, filterFunc: ( setValue: any ) => any ): void\r\n\t{\r\n\t\tif ( !_class[storeSetFilterKey] ) _class[storeSetFilterKey] = {};\r\n\t\tif ( !_class[storeSetFilterKey][propertyName] ) _class[storeSetFilterKey][propertyName] = [];\r\n\t\t_class[storeSetFilterKey][propertyName].push( filterFunc );\r\n\t}\r\n\r\n\t/** @private */\r\n\tfunction getSetter( _class: any, propertyName: string, observable: KnockoutObservable<any> ): any\r\n\t{\r\n\t\tif ( !_class[storeSetFilterKey] ) return observable;\r\n\t\tlet filters = _class[storeSetFilterKey][propertyName];\r\n\t\tif ( !filters ) return observable;\r\n\t\tlet len = filters.length;\r\n\t\treturn (v:any) =>\r\n\t\t{\r\n\t\t\tlet original = v;\r\n\t\t\tfor ( let i = 0; i < len; ++i )\r\n\t\t\t{\r\n\t\t\t\tv = filters[i]( v );\r\n\t\t\t}\r\n\t\t\tobservable( v );\r\n\t\t}\r\n\t}\r\n\r\n\t/** @private */\r\n\tfunction assignExtendForInstancedObj( _class:any, instancedObj: any, propertyName: string ): void\r\n\t{\r\n\t\tlet o = getObservableObject( instancedObj, propertyName );\r\n\t\tlet ext = getExtend( _class, propertyName );\r\n\t\tif ( ext ) o.extend( ext );\r\n\t}\r\n\t// #endregion\r\n\r\n\tif ( typeof exports !== typeof undefined )\r\n\t{\r\n\t\tmodule.exports = KnockoutDecorator;\r\n\t\tmodule.exports[\"default\"] = KnockoutDecorator;\r\n\t}\r\n\t\r\n}\r\n\r\nexport = KnockoutDecorator;\r\n"],"sourceRoot":"/source/"}