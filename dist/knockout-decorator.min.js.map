{"version":3,"sources":["knockout-decorator.ts"],"names":["require","exports","KnockoutDecorator","track","arg","classFactory","constructor","kd","KnockoutDecoratorClassInfo","Get","trackConstructor","apply","this","arguments","o","properties","Object","keys","len","length","i","p","KnockoutDecoratorObjInfo","Key","isIgnoreProperty","getObservable","getObservableArray","v","Array","isArray","observableArray","prototype","observable","functions","computedAccessors","i_1","f","d","getOwnPropertyDescriptor","get","getComputed","getComputedDecoratorFactory","pure","options","pureComputed","defineProperty","push","i_2","init","initializeMethod","defaults","key","undefined","ignore","target","property","pushIgnoreProperty","makeObservable","set","value","makeObservableArray","arrayValue","computed","propertyName","descriptor","extend","name","pushKoExtend","setFilter","filterFunc","pushSetFilter","parseFloat","isNaN","min","minValue","max","maxValue","clamp","tmp","lastGetKoObservable","res","lastGetKoObservableArray","lastGetKoComputed","accessor","getter","setter","makeComputed","ignoreProperties","indexOf","extendOptions","extendsHash","applyKoExtend","extendArr","setFiltersHash","filters","getSetter","koObservableHash","koObservableArrayHash","koComputedHash","ko","getPrototypeOf","classInfo","replaceFunction","src","originals","forEach","fnName","mimicry","mergeFunction","computedOptions","read","write","owner","c","module"],"mappings":";;;;;oRAOAA,EAAOC,sCAoGFC,YAEFC,EAAOC,YAkCNC,EAAYC,OACZC,EAAKC,EAAQC,IAAAH,GAEbI,EAAiB,WACjBJ,EAAUK,MAAAC,KAAWC,mBACjBC,EAAEF,KAELG,EAAQC,OAAYC,KAAEH,GACtBI,EAAMH,EAAKI,OACVC,EAAG,EAAAA,EAAAF,IAAgBE,EAAK,KACxBC,EAAAN,EAAgBK,QAChBC,IAAAC,EACAC,KACAhB,EAAAiB,iBAASH,IACTI,EAAAX,EAAAO,IAEGK,EAASZ,EAAAO,SAIZM,EAAAb,EAAAO,UACAP,EAAAO,GACGO,MACHC,QAAAF,GACAG,EAAYpB,EAAiBqB,UAAeV,GAG7CW,EAAAtB,EAAAqB,UAAAV,GAGGP,EAAAO,GAAAM,GAEJ,IAAIM,EAAWjB,OAAGC,KAAMX,EACvByB,WACAG,OACAD,EAAQd,WACR,IAAMgB,EAAM,EAAEA,EAAKjB,IAAAiB,EAAA,KAACC,EAAAH,EAASE,GACxBE,EAAGrB,OAAAsB,yBAAuBhC,EAAAyB,UAAAK,MAACC,GAAAA,EAASE,MAGrChC,EAAAiB,iBAAaY,GAAjB,CAGWtB,EAAGsB,GACbI,EAAM1B,EAAQsB,KAENK,GACTC,KAAOC,EAAAC,eAEPlC,EAAAqB,UAAAK,EAAAC,GACDrB,OAAA6B,eAAAnC,EAAAqB,UAA4CK,EAAAC,GACzCH,EAAGY,KAAkBV,KAIxBlB,EAACgB,EAAAf,OAED,IAAK,IAAA4B,EAAQ,EAAIA,EAAI7B,IAAS6B,EAE7BjC,EAAEoB,EAAgBa,IAEdJ,EAAQK,MAA6B,mBAA7BlC,EAAgB6B,EAAIK,OAEhClC,EAAE6B,EAAQK,QAEXL,EAAAM,kBAAA,mBAAAnC,EAAA6B,EAAAM,mBACDnC,EAAA6B,EAAiBM,qBAMjB,OAFIvC,EACJ,UAAAJ,EAAA,UACOI,WAxGN,mBAAAN,KAEDwC,cAAA,EAEAK,iBAAA,eAKCC,GACkBN,cAAA,EACdK,iBACJ,KACAD,KAAA,MAED,KAPC5C,MAcE,IAAA+C,KAAAD,OACDE,IAAAT,EAAAQ,KACDR,EAAAQ,GAAAD,EAAAC,SAPAR,EAAUO,EAyFZ,MACC,mBAAA9C,EACOC,EAAWD,GAIlB,SAAAE,GACD,OAAAD,EAAAC,IAMe,SAAA+C,EAAAC,EAAMC,GAKtB/C,EAAAC,IAAA6C,GAAAE,mBAAAD,cASGxB,EAAAwB,yBACYxB,EAAUwB,GACvBhB,IAAC,WAGA,OAFEjB,EAAuBb,IAAAG,MAAA6C,eAAAF,GAEzB3C,KAAA2C,IAEDG,IAAC,SAAAC,GACErC,EAAAb,IAAAG,MAAA6C,eAAAF,GACJ3C,KAAA2C,GAAAI,gBAWE5B,EAAwBwB,yBACZxB,EAAUwB,GACvBhB,IAAC,WAGA,OAFEjB,EAA4Bb,IAAAG,MAAAgD,oBAAAL,GAE9B3C,KAAA2C,IAEDG,IAAC,SAAAG,GACEvC,EAAAb,IAAAG,MAAAgD,oBAAAL,GACJ3C,KAAA2C,GAAAM,cAqBCC,IACD,GAAA,GAAAjD,UAAAM,OACA,OAAAsB,EAAA5B,UAAA,IAED4B,EAAA,MAAA9B,MAAAC,KAAAC,WAKgB,SAAA+B,EAAAb,EAAYgC,EAG3BC,GAEDvB,GAAAC,MAAA,IAAAX,EAAAgC,EAAAC,YASGC,EAAAtB,GACF,OAAA,SAAAZ,EAAAmC,EAAAF,GANexD,EAMfC,IAAAsB,GAAAoC,aAAAD,EAAAvB,aAcEyB,EAAAC,GACF,OAAA,SAAAtC,EAAAwB,GANe/C,EAASC,IAMxBsB,GAAAuC,cAAAf,EAAAc,eAW0CtC,EAAGwB,KACxB9C,IAAAsB,GAAAuC,cAAAf,EAAA,SAAA5B,GACpB,OAAAA,GAAyB,iBAARA,GAElBA,EAAA4C,WAAA5C,GARe6C,MAAA7C,GAAQ,EAAAA,GAOnBA,IAOW,SAAA8C,EAAAC,GAKhB,OAAAN,EAAA,SAAAzC,GAAA,OAAAA,EAAA+C,EAAAA,EAAA/C,IAKgB,SAAAgD,EAAAC,GAKhB,OAAAR,EAAA,SAAAzC,GAAA,OAAAA,EAAAiD,EAAAA,EAAAjD,aASEkD,EAAAH,EAAWE,MACXF,EAAWE,EAAI,CACf,IAAAE,EAAAJ,EACDA,EAAOE,EAENA,EAASE,SACTV,EAAc,SAAUzC,GAXV,OAWWA,EAAI+C,EAC7B/C,EAAQ+C,EACL/C,EAAAiD,IACJjD,EAAAiD,GAdejD,aAkCdF,OACU,mBAAHZ,UAAG,GAAoB,CAC9BkE,EAAsB,KACtBlE,UAAU,KACV,IAAAmE,EAAAD,EAGA,OAFGA,EACH,KACIC,EAGJ,IAAA1B,EAAAzC,UAAA,GACD0C,EAAA1C,UAAA,GAhBe,OAAAS,EAAab,IAAA6C,GAgB5B7B,cAAA8B,YAkBC7B,OACU,mBAAHb,UAAG,GAMV,OALAoE,EAA2B,KAC3BpE,UAAU,KAEPkE,EACH,KAFAE,EAMA,IAAA3B,EAAAzC,UAAA,GACD0C,EAAA1C,UAAA,GAhBe,OAAAS,EAAkBb,IAAA6C,GAAA5B,mBAgBjC6B,YAoBCf,OACU,mBAAH3B,UAAG,GAAkB,CAC5BqE,EAAoB,KACpBrE,UAAU,KACV,IAAAmE,EAAAE,EAGA,OAFGA,EACH,KACIF,EAGJ,IAAA1B,EAAAzC,UAAA,GAEDsE,EAAAtE,UAAA,GAjBe,OAAAS,EAAWb,IAiB1B6C,GAAAd,YAAA2C,YAUC1C,EACCE,mBACMZ,EAAAoD,EAAAnB,GACP,IAACoB,EAAApB,EAAAzB,IACD,IAAI6C,EAEJ,KAAU,kDAGTC,EAAOrB,EAAaN,IACrBM,EAACzB,IAAA,WAGA,OAFIjB,EACJb,IAAAG,MAAA0E,aAAAH,EAAAC,EAAAC,EAAA1C,GACA/B,KAAWuE,QAIXnB,EAACN,IAAA,SAAAC,GACDrC,EAAAb,IAAAG,MAAA0E,aAAAH,EAAAC,EAAAC,EAAA1C,GACD/B,KAAAuE,GAAAxB,2CAvNO7B,gBAAAA,wFAiHP+C,MAAAA,IA6BApD,cAAwBA,IA+BxBC,mBAA0BA,EAkB5BxB,EAAAsC,YAAAA,EA+BA,IAAAuC,EAAA,KACAE,EAAA,KA4ECC,EAAA,KAxEc1E,EAAG,oBAEhBA,KAyEF,SAtEUC,IAAA,SAA2B6C,GAOnC,OANAA,EAAC,mBAAAA,EAAAA,EAAAvB,UAAAuB,GACM9C,EAAOe,OACd+B,EAAA9C,EAAAe,KAAA,IAAAX,MAIM0C,EAAK9C,EAAkBe,QACPQ,UAAMyB,mBAAW,SAAAD,GACvC3C,KAAA2E,mBACM3E,KAAA2E,qBAEN3E,KAAA2E,iBAAYzC,KAAAS,IAEb/C,EAACuB,UAAAP,iBAAA,SAAA+B,GAEM,OAAA3C,KAAA2E,mBAEkB,GAAnB3E,KAAK2E,iBAAcC,QAAAjC,MACDxB,UAAOoC,aAAA,SAAAD,EAAAuB,GAAC7E,KAAK8E,cAChC9E,KAAC8E,gBACL9E,KAAA8E,YAAAxB,KAEMtD,KAAA8E,YAAAxB,OAENtD,KAAM8E,YAAKxB,GAAapB,KAAA2C,MACH1D,UAAY4D,cAAQ,SAAArC,EAAAxC,GACzC,GAAMF,KAAA8E,YAAN,CACA,IAAIE,EAAMhF,KAAU8E,YAAOpC,GAC3B,GAAMsC,EAIN,IAAA,IADC1E,EAAA0E,EAAAzE,OACDC,EAAA,EAAAA,EAAAF,IAAAE,EAEMN,EAAAmD,OAAA2B,EAAAxE,QAGaW,UAAcuC,cAAU,SAAAf,EAAAc,GACrCzD,KAAAiF,iBAELjF,KAAAiF,mBACD,IAACC,EAAAlF,KAAAiF,eAAAtC,GACDuC,IACAA,EAAAlF,KAAAiF,eAAAtC,OAIAuC,EAAMhD,KAAKuB,MACQtC,UAAcgE,UAAS,SAAAzC,EAAAxC,GAC1C,IAAMF,KAAAiF,eAAU,OAAO/E,EACvB,IAAIgF,EAAMlF,KAAQiF,eAAOvC,GACzB,IAAAwC,EAEC,OAAMhF,QAEJgF,EAAG3E,cACJ,SAAAQ,GACD,IAAO,IAAAP,EAAA,EAAAA,EAAAF,IAAAE,EACPO,EAAAmE,EAAA1E,GAAAO,GASHb,EAAAa,KAEAnB,OA6ICe,IAAA,yCAHQ,oBACAD,EAAmEgC,GAI1E1C,KAAKoF,oBACLpF,KAAAqF,yBA7IarF,KAAAsF,kBAEbtF,KAAM0C,OAAOA,EA6If,SA1IG7C,IAAA,SAAA6C,GAMD,OALAA,EAAOhC,EAAOC,OACd+B,EAAAhC,EAAAC,KAAA,IAAAX,KAAA0C,IAIKA,EAAMhC,EAAkBC,QAEbQ,UAAO0B,eAAqB,SAAQF,GACpD,IAAIzC,EAAAqF,GAAAnE,aACJpB,KAAAoF,iBAAUzC,GAAyBzC,EAAK,IAAAiB,EAAAf,OAAAoF,eAAgCxF,KAAW0C,QACnF+C,EAAO7F,EAAqCC,IAAEsB,KACxC4D,cAAApC,EAAAzC,KAEeL,IAAIsB,yBACZnB,KAAA0C,OAAAC,GACZhB,IAAC,WAEE,OADAwC,EAAuBjE,EACvBA,KAGE4C,IAAA2C,EAAAN,UAAAxC,EAAAzC,QAKWiB,UAAU6B,oBAAoB,SAAWL,YAExD+C,EAAiBC,EAAUzF,OAC3B0F,eAEC,MAAA,OAAA,QAAA,UAAA,UAAA,QAAAC,QAAA,SAAoEC,KACvDA,GAAUH,EAAAG,OAEvBC,EAAA,WAGAJ,EAAAG,GAAAF,EAAAE,GAGA,IAAA1B,EAAUlE,EAAC4F,GAAA/F,MAAAG,EAAAD,WAIC,OADb0F,EAAAG,GAAAC,EACoB3B,GAGtBuB,EAAAG,GAAAC,eAMcJ,EAAqBzF,cAC/B,SAAA,YAAA,UAAA,cAAA2F,QAAA,SAAAC,GACCH,EAAAG,GAAA,WACJ,OAAA5F,EAAA4F,GAAA/F,MAAAG,EAAAD,cAKD,IAAIC,EAAAqF,GAAArE,kBACJlB,KAAAqF,sBAAyB1C,GAAczC,EAAC,IAAAiB,EAAAf,OAAAoF,eAAgCxF,KAAW0C,QAEnF+C,EAAO7F,EAAqCC,IAAEsB,KACxC4D,cAAApC,EAAAzC,KAEJL,IAAAsB,yBACWnB,KAAA0C,OAAAC,GACZhB,IAAC,WAGA,OAFE0C,EAA8BnE,EAE3BA,kBAGJ+C,GACAA,IACDyC,EAAqBzC,EAAa/C,GAClC8F,EAAA/C,EAAA/C,IAGFuF,EAAAN,UAAAxC,EAAAzC,GAAA+C,SAMc9B,UAAAuD,aAAA,SAAAH,EAAAC,EAAAC,EAAA1C,OACbkE,GACCC,KAAA1B,EACG2B,MAAQ1B,EAEZ2B,MAAMpG,KAAO0C,WAGbX,EACA,IAAA,IAAAQ,KAAAR,EACOkE,EAAa1D,GAAAR,EAAkBQ,GAGvC,IAAI8D,EAAAd,GAAArC,SAAY+C,GAChBjG,KAAAsF,eAAUf,GAAuB8B,EACjC,IAAAlF,EAAOf,OAAgBoF,eAAaxF,KAAQ0C,QAC3C+C,EAAI7F,EAAAC,IAAAsB,KAEH4D,cAAAR,EAAsB8B,yBACXrG,KAAA0C,OAAA6B,GACZ5C,IAAC,WAEE,OADA2C,EAAqB+B,EACrBA,KAGEvD,IAAA2B,EAAAgB,EAAAN,UAAAZ,EAAP8B,QAAA7D,KAKO9B,EAAAS,UAAAN,cAAA,SAAP8B,GAEC,OAAO3C,KAAKoF,iBAAAzC,IAGNjC,EAAAS,UAAAL,mBAAP,SAAuB6B,GAEtB,OAAO3C,KAAKqF,sBAAe1C,IAa7BjC,EAAAS,UAACS,YAAA,SAAA2C,GAhJD,OAAAvE,KAAAsF,eAAAf,IAiJA7D,KAGAA,EAAwBC,IAAO,sCAI9B,IAAAtB,IAruBKiH,OAAAjH,QAAAC,EAwuBEgH,OAAAjH,QAAkB,QAAAC","file":"knockout-decorator.min.js","sourcesContent":["/*!\r\n * Knockout decorator\r\n * (c) vario\r\n * License: MIT (http://www.opensource.org/licenses/mit-license.php)\r\n */\r\n\r\n\r\nmodule KnockoutDecorator\r\n{\r\n\t// #region declare interfaces.\r\n\t/**\r\n\t * You can easily access KnockoubObservableArray functions via intellisense\r\n\t * by casting a array property which is attaching @observableArray.\r\n\t */\r\n\texport interface IObservableArray<T> extends Array<T>\r\n\t{\r\n\t\t/** Execute KnockoutObservableArray.replace */\r\n\t\treplace( oldItem: T, newItem: T ): void;\r\n\r\n\t\t/** Execute KnockoutObservableArray.remove */\r\n\t\tremove( item: T ): T[];\r\n\r\n\t\t/** Execute KnockoutObservableArray.remove */\r\n\t\tremove( removeFunction: ( item: T ) => boolean ): T[];\r\n\r\n\t\t/** Execute KnockoutObservableArray.removeAll */\r\n\t\tremoveAll( items: T[] ): T[];\r\n\r\n\t\t/** Execute KnockoutObservableArray.removeAll */\r\n\t\tremoveAll(): T[];\r\n\r\n\t\t/** Execute KnockoutObservableArray.destroy */\r\n\t\tdestroy( item: T ): void;\r\n\r\n\t\t/** Execute KnockoutObservableArray.destroy */\r\n\t\tdestroy( destroyFunction: ( item: T ) => boolean ): void;\r\n\r\n\t\t/** Execute KnockoutObservableArray.destroyAll */\r\n\t\tdestroyAll( items: T[] ): void;\r\n\r\n\t\t/** Execute KnockoutObservableArray.destroyAll */\r\n\t\tdestroyAll(): void;\r\n\t}\r\n\r\n\t/**\r\n\t * @computed argument options.\r\n\t */\r\n\texport interface IComputedOptions\r\n\t{\r\n\t\tdisposeWhenNodeIsRemoved?: Node;\r\n\t\tdisposeWhen?(): boolean;\r\n\t\tdeferEvaluation?: boolean;\r\n\t\tpure?: boolean;\r\n\t}\r\n\r\n\t// #endregion\r\n\r\n\t/**\r\n\t * Argument of @track decorator.\r\n\t */\r\n\texport interface ITrackOptions\r\n\t{\r\n\t\t/**\r\n\t\t * Make accessors pure koComputed if true or undefined, else non pure koComputed.\r\n\t\t */\r\n\t\tpureComputed?: boolean,\r\n\r\n\t\t/**\r\n\t\t * Deprecated. Use init instead.\r\n\t\t * If value set, perform obj[initializeMethod]() immediate after executed constructor.\r\n\t\t */\r\n\t\tinitializeMethod?: string,\r\n\r\n\t\t/**\r\n\t\t * If value set, perform obj[init]() immediate after executed constructor.\r\n\t\t * In order to use raw koObservable if you use track decorator,\r\n\t\t * it is necessary to be not inside constructor but after executed constructor.\r\n\t\t */\r\n\t\tinit?: string;\r\n\r\n\t\t[key: string]: any\r\n\t}\r\n\t/**\r\n\t * Class decorator.\r\n\t * Make all properties/accessors to koObservable/koComputed.\r\n\t * Points to consider.\r\n\t * 1. Properties that are not initialized at declare or in constructor don't become koObservable.\r\n\t * 2. In order to recognize a array property as koObservableArray, it is necessary to set a array value first(e.g set [] ).\r\n\t * 3. Accessors become pure koComputed.\r\n\t * 4. A property/accessor with `@ignore` don't become koObservable.\r\n\t * 5. In order to use raw koObservable, it is necessary to be not inside constructor but after executed constructor.\r\n\t */\r\n\texport function track( constructor: Function ): any;\r\n\t/**\r\n\t * Class decorator.\r\n\t * Make all properties/accessors to koObservable/koComputed.\r\n\t * Points to consider.\r\n\t * 1. Properties that are not initialized at declare or in constructor don't become koObservable.\r\n\t * 2. In order to recognize a array property as koObservableArray, it is necessary to set a array value first(e.g set [] ).\r\n\t * 3. Accessors become pure koComputed.\r\n\t * 4. A property/accessor with `@ignore` don't become koObservable.\r\n\t * 5. In order to use raw koObservable, it is necessary to be not inside constructor but after executed constructor.\r\n\t */\r\n\texport function track( options: ITrackOptions ): any;\r\n\texport function track( arg: any ): any\r\n\t{\r\n\t\tlet options: ITrackOptions;\r\n\t\tif ( typeof arg === \"function\" )\r\n\t\t{\r\n\t\t\toptions = {\r\n\t\t\t\tpureComputed: true,\r\n\t\t\t\tinitializeMethod: null\r\n\t\t\t};\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\toptions = arg;\r\n\t\t\tlet defaults = {\r\n\t\t\t\tpureComputed: true,\r\n\t\t\t\tinitializeMethod: null,\r\n\t\t\t\tinit: null\r\n\t\t\t} as ITrackOptions;\r\n\t\t\tif ( !options )\r\n\t\t\t{\r\n\t\t\t\toptions = defaults;\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tfor ( let key in defaults )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( options[key] === undefined )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\toptions[key] = defaults[key];\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tfunction classFactory( constructor: Function )\r\n\t\t{\r\n\t\t\tlet kd = KnockoutDecoratorClassInfo.Get( constructor );\r\n\t\t\tlet trackConstructor: any = function ()\r\n\t\t\t{\r\n\t\t\t\tconstructor.apply( this, arguments );\r\n\t\t\t\tlet o = this;\r\n\r\n\t\t\t\tlet properties = Object.keys( o );\r\n\t\t\t\tlet len = properties.length;\r\n\t\t\t\tfor ( var i = 0; i < len; ++i )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet p = properties[i];\r\n\t\t\t\t\tif ( p === KnockoutDecoratorObjInfo.Key ||\r\n\t\t\t\t\t\tkd.isIgnoreProperty( p ) ||\r\n\t\t\t\t\t\tgetObservable( o, p ) ||\r\n\t\t\t\t\t\tgetObservableArray( o, p ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tcontinue;\r\n\t\t\t\t\t}\r\n\r\n\t\t\t\t\tlet v = o[p];\r\n\t\t\t\t\tdelete o[p];\r\n\t\t\t\t\tif ( Array.isArray( v ) )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tobservableArray( trackConstructor.prototype, p );\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tobservable( trackConstructor.prototype, p );\r\n\t\t\t\t\t}\r\n\t\t\t\t\to[p] = v;\r\n\t\t\t\t}\r\n\r\n\t\t\t\tlet functions = Object.keys( constructor.prototype );\r\n\t\t\t\tlet computedAccessors: any[] = [];\r\n\t\t\t\tlen = functions.length;\r\n\t\t\t\tfor ( let i = 0; i < len; ++i )\r\n\t\t\t\t{\r\n\t\t\t\t\tlet f = functions[i];\r\n\t\t\t\t\tlet d = Object.getOwnPropertyDescriptor( constructor.prototype, f );\r\n\t\t\t\t\tif ( !d || !d.get ) continue;\r\n\t\t\t\t\tif ( kd.isIgnoreProperty( f ) ) continue;\r\n\r\n\t\t\t\t\t// If be Overrided descriptor already, accessor become koComputed by executing the following;\r\n\t\t\t\t\tlet dummy = o[f];\r\n\t\t\t\t\tif ( getComputed( o, f ) ) continue;\r\n\r\n\t\t\t\t\tlet factory = getComputedDecoratorFactory( {\r\n\t\t\t\t\t\tpure: options.pureComputed\r\n\t\t\t\t\t} );\r\n\t\t\t\t\tfactory( trackConstructor.prototype, f, d );\r\n\t\t\t\t\tObject.defineProperty( trackConstructor.prototype, f, d );\r\n\t\t\t\t\tcomputedAccessors.push( f );\r\n\t\t\t\t}\r\n\t\t\t\t// In order to make koComputed, call getter.\r\n\t\t\t\tlen = computedAccessors.length;\r\n\t\t\t\tfor ( let i = 0; i < len; ++i )\r\n\t\t\t\t{\r\n\t\t\t\t\to[computedAccessors[i]];\r\n\t\t\t\t}\r\n\t\t\t\t\r\n\t\t\t\tif ( options.init && typeof o[options.init] === \"function\" )\r\n\t\t\t\t{\r\n\t\t\t\t\to[options.init]();\r\n\t\t\t\t}\r\n\t\t\t\tif ( options.initializeMethod && typeof o[options.initializeMethod] === \"function\" )\r\n\t\t\t\t{\r\n\t\t\t\t\to[options.initializeMethod]();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\ttrackConstructor[\"prototype\"] = constructor[\"prototype\"];\r\n\t\t\treturn trackConstructor;\r\n\t\t}\r\n\r\n\t\tif ( typeof arg === \"function\" )\r\n\t\t{\r\n\t\t\treturn classFactory( arg );\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\treturn function ( constructor: Function )\r\n\t\t\t{\r\n\t\t\t\treturn classFactory( constructor );\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Property/Accessor decorator.\r\n\t * Prevent a property/accessor from making koObservable in @trak.\r\n\t */\r\n\texport function ignore( target: any, property: string ): void\r\n\t{\r\n\t\tKnockoutDecoratorClassInfo.Get( target ).pushIgnoreProperty( property );\r\n\t}\r\n\r\n\t/**\r\n\t * Property decorator.\r\n\t * Make a property koObservable.\r\n\t */\r\n\texport function observable( prototype: Object, property: string ): void\r\n\t{\r\n\t\tObject.defineProperty( prototype, property, {\r\n\t\t\tget: function (): any\r\n\t\t\t{\r\n\t\t\t\tKnockoutDecoratorObjInfo.Get( this ).makeObservable( property );\r\n\t\t\t\treturn this[property];\r\n\t\t\t},\r\n\t\t\tset: function ( value: any ): void\r\n\t\t\t{\r\n\t\t\t\tKnockoutDecoratorObjInfo.Get( this ).makeObservable( property );\r\n\t\t\t\tthis[property] = value;\r\n\t\t\t}\r\n\t\t} );\r\n\t}\r\n\r\n\t/**\r\n\t * Property decorator.\r\n\t * Make a property koObservableArray.\r\n\t */\r\n\texport function observableArray( prototype: any, property: string ): void\r\n\t{\r\n\t\tObject.defineProperty( prototype, property, {\r\n\t\t\tget: function (): any[]\r\n\t\t\t{\r\n\t\t\t\tKnockoutDecoratorObjInfo.Get( this ).makeObservableArray( property );\r\n\t\t\t\treturn this[property];\r\n\t\t\t},\r\n\t\t\tset: function ( arrayValue: any ): void\r\n\t\t\t{\r\n\t\t\t\tKnockoutDecoratorObjInfo.Get( this ).makeObservableArray( property );\r\n\t\t\t\tthis[property] = arrayValue;\r\n\t\t\t}\r\n\t\t} );\r\n\t}\r\n\r\n\t/**\r\n\t * Accessor decorator.\r\n\t * At least require getter.\r\n\t * Make a accessor koComputed. If setter is defined, make it writable computed.\r\n\t */\r\n\texport function computed( prototype: any, propertyName: string, descriptor: PropertyDescriptor ): void\r\n\t/**\r\n\t * Accessor decorator.\r\n\t * At least require getter.\r\n\t * Make a accessor koComputed. If setter is defined, make it writable computed.\r\n\t * @param options\tKnockout computed options.\r\n\t * @see <a href=\"http://knockoutjs.com/documentation/computed-reference.html\" target=\"_blank\">Computed Observable Reference</a>\r\n\t */\r\n\texport function computed( options: IComputedOptions ): MethodDecorator;\r\n\texport function computed(): any\r\n\t{\r\n\t\tif ( arguments.length == 1 )\r\n\t\t{\r\n\t\t\treturn getComputedDecoratorFactory( arguments[0] );\r\n\t\t}\r\n\t\tgetComputedDecoratorFactory( null ).apply( this, arguments );\r\n\t}\r\n\r\n\t/**\r\n\t * Accessor decorator.\r\n\t * At least require getter.\r\n\t * Make a accessor koPureComputed. If setter is defined, make it writable computed.\r\n\t */\r\n\texport function pureComputed( prototype: any, propertyName: string, descriptor: PropertyDescriptor ): void\r\n\t{\r\n\t\tgetComputedDecoratorFactory( { pure: true } )( prototype, propertyName, descriptor );\r\n\t}\r\n\r\n\t/**\r\n\t * Property/Accessor decorator.\r\n\t * @param options\tSet options which is defined ko.extenders such as rateLimit.\r\n\t */\r\n\texport function extend( options: { [key: string]: any } ): any\r\n\t{\r\n\t\treturn ( prototype: any, name: string, descriptor?: PropertyDescriptor ) =>\r\n\t\t{\r\n\t\t\tKnockoutDecoratorClassInfo.Get( prototype ).pushKoExtend( name, options );\r\n\t\t};\r\n\t}\r\n\r\n\t//#region set filter decorators\r\n\t/**\r\n\t * Property/Setter decorator.\r\n\t * A value set to a property becom return value of filter.\r\n\t * If there is multiple set filter decorators for a property, there are executed in the order from bottom to top.\r\n\t * @param filterFunc function that return a processed value.\r\n\t */\r\n\texport function setFilter( filterFunc: ( setValue: any ) => any ): any // PropertyDecorator | MethodDecorator\r\n\t{\r\n\t\treturn ( prototype: any, property: string ) =>\r\n\t\t{\r\n\t\t\tKnockoutDecoratorClassInfo.Get( prototype ).pushSetFilter( property, filterFunc );\r\n\t\t};\r\n\t}\r\n\r\n\t/**\r\n\t * Set filter decorator.\r\n\t * Variable keeps numerical type.\r\n\t * If set value is NaN, it become zero.\r\n\t */\r\n\texport function asNumber( prototype: any, property: string ): any\r\n\t{\r\n\t\tKnockoutDecoratorClassInfo.Get( prototype ).pushSetFilter( property, v =>\r\n\t\t{\r\n\t\t\tif ( !v || typeof v === \"number\" ) return v;\r\n\t\t\tv = parseFloat( v );\r\n\t\t\treturn isNaN( v ) ? 0 : v;\r\n\t\t} );\r\n\t}\r\n\r\n\t/**\r\n\t * Set filter decorator.\r\n\t * Variable keeps greater than or equal to minValue.\r\n\t */\r\n\texport function min( minValue: number ): any // PropertyDecorator | MethodDecorator\r\n\t{\r\n\t\treturn setFilter( v => v < minValue ? minValue : v );\r\n\t}\r\n\r\n\t/**\r\n\t * Set filter decorator.\r\n\t * Variable keeps less than or equal to maxValue.\r\n\t * @extend require attaching observable decorator.\r\n\t */\r\n\texport function max( maxValue: number ): any // PropertyDecorator | MethodDecorator\r\n\t{\r\n\t\treturn setFilter( v => v > maxValue ? maxValue : v );\r\n\t}\r\n\r\n\t/**\r\n\t * Set filter decorator.\r\n\t * Variable keeps between minValue and maxValue inclusive.\r\n\t */\r\n\texport function clamp( minValue: number, maxValue: number ): any // PropertyDecorator | MethodDecorator\r\n\t{\r\n\t\tif ( minValue > maxValue )\r\n\t\t{\r\n\t\t\tlet tmp = minValue;\r\n\t\t\tminValue = maxValue;\r\n\t\t\tmaxValue = tmp;\r\n\t\t}\r\n\t\treturn setFilter( v =>\r\n\t\t{\r\n\t\t\tif ( v < minValue ) v = minValue;\r\n\t\t\telse if ( v > maxValue ) v = maxValue;\r\n\t\t\treturn v;\r\n\t\t} );\r\n\t}\r\n\t//#endregion\r\n\r\n\t/**\r\n\t * Get raw knockout observable object.\r\n\t * @param target\tTarget object.\r\n\t * @param property\tName of a property which is attached the @observable.\r\n\t * @return If found then KnockoutObservable object, else null.\r\n\t */\r\n\texport function getObservable<T>( target: any, property: string ): KnockoutObservable<T>;\r\n\t/**\r\n\t * Get raw knockout observable object.\r\n\t * @param propertyAccess\texecute propety access. e.g. \"() => this.property\".\r\n\t */\r\n\texport function getObservable<T>( propertyAccess: () => T ): KnockoutObservable<T>;\r\n\texport function getObservable<T>(): KnockoutObservable<T>\r\n\t{\r\n\t\tif ( typeof arguments[0] === \"function\" )\r\n\t\t{\r\n\t\t\tlastGetKoObservable = null;\t// reset\r\n\t\t\targuments[0]();\r\n\t\t\tlet res = lastGetKoObservable;\r\n\t\t\tlastGetKoObservable = null;\r\n\t\t\treturn res;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlet target = arguments[0];\r\n\t\t\tlet property = arguments[1];\r\n\t\t\treturn KnockoutDecoratorObjInfo.Get( target ).getObservable<T>( property );\r\n\t\t}\r\n\t}\r\n\t\r\n\t/**\r\n\t * Get row knockout observable array object.\r\n\t * @param target\tTarget object.\r\n\t * @param property\tName of a property which is attached the @observableArray.\r\n\t */\r\n\texport function getObservableArray<T>( target: any, property: string ): KnockoutObservableArray<T>;\r\n\t/**\r\n\t * Get row knockout observable array object.\r\n\t * @param propertyAccess\texecute propety access. e.g. \"() => this.property\".\r\n\t */\r\n\texport function getObservableArray<T>( propertyAccess: () => T[] ): KnockoutObservableArray<T>;\r\n\texport function getObservableArray<T>(): KnockoutObservableArray<T>\r\n\t{\r\n\t\tif ( typeof arguments[0] === \"function\" )\r\n\t\t{\r\n\t\t\tlastGetKoObservableArray = null;\t// reset\r\n\t\t\targuments[0]();\r\n\t\t\tlet res = lastGetKoObservableArray;\r\n\t\t\tlastGetKoObservable = null;\r\n\t\t\treturn res;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlet target = arguments[0];\r\n\t\t\tlet property = arguments[1];\r\n\t\t\treturn KnockoutDecoratorObjInfo.Get( target ).getObservableArray<T>( property );\r\n\t\t}\r\n\t}\r\n\r\n\t/**\r\n\t * Get raw knockout computed object.\r\n\t * @param target\tTarget object.\r\n\t * @param property\tName of a accessor which is attached the @computed.\r\n\t * @return If found then KnockoutComputed object, else null.\r\n\t */\r\n\texport function getComputed<T>( target: any, accessor: string ): KnockoutComputed<T>;\r\n\t/**\r\n\t * Get raw knockout computed object.\r\n\t * @param getterAccess\texecute getter. e.g. \"() => this.getter\".\r\n\t * @return If found then KnockoutComputed object, else null.\r\n\t */\r\n\texport function getComputed<T>( getterAccess:()=>T ): KnockoutComputed<T>;\r\n\texport function getComputed<T>(): KnockoutComputed<T>\r\n\t{\r\n\t\tif ( typeof arguments[0] === \"function\" )\r\n\t\t{\r\n\t\t\tlastGetKoComputed = null;\t// reset\r\n\t\t\targuments[0]();\r\n\t\t\tlet res = lastGetKoComputed;\r\n\t\t\tlastGetKoComputed = null;\r\n\t\t\treturn res;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tlet target = arguments[0];\r\n\t\t\tlet accessor = arguments[1];\r\n\t\t\treturn KnockoutDecoratorObjInfo.Get( target ).getComputed<T>( accessor );\r\n\t\t}\r\n\t\t\r\n\t}\r\n\r\n\t// #region no export\r\n\r\n\t/** @private */\r\n\tfunction getComputedDecoratorFactory( options: IComputedOptions ): MethodDecorator\r\n\t{\r\n\t\treturn ( prototype: Object, accessor: string, descriptor: PropertyDescriptor ) =>\r\n\t\t{\r\n\t\t\tlet getter = descriptor.get;\r\n\t\t\tif ( !getter )\r\n\t\t\t{\r\n\t\t\t\tthrow \"@Computed and @pureComputed require getter.\";\r\n\t\t\t}\r\n\t\t\tlet setter = descriptor.set;\r\n\r\n\t\t\tdescriptor.get = function ()\r\n\t\t\t{\r\n\t\t\t\tKnockoutDecoratorObjInfo.Get( this ).makeComputed( accessor, getter, setter, options );\r\n\t\t\t\treturn this[accessor];\r\n\t\t\t}\r\n\t\t\tif ( setter )\r\n\t\t\t{\r\n\t\t\t\tdescriptor.set = function ( value )\r\n\t\t\t\t{\r\n\t\t\t\t\tKnockoutDecoratorObjInfo.Get( this ).makeComputed( accessor, getter, setter, options );\r\n\t\t\t\t\tthis[accessor] = value;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\r\n\tlet lastGetKoObservable: KnockoutObservable<any> = null;\r\n\tlet lastGetKoObservableArray: KnockoutObservableArray<any> = null;\r\n\tlet lastGetKoComputed: KnockoutComputed<any> = null;\r\n\r\n\t// Information that class should have.\r\n\tclass KnockoutDecoratorClassInfo\r\n\t{\r\n\t\tpublic static Get( constructor: Function ): KnockoutDecoratorClassInfo;\r\n\t\tpublic static Get( prototype: Object ): KnockoutDecoratorClassInfo;\r\n\t\tpublic static Get( target: any ): KnockoutDecoratorClassInfo\r\n\t\t{\r\n\t\t\ttarget = ( typeof target == \"function\" ) ? target.prototype : target;\r\n\t\t\tif ( !target[KnockoutDecoratorClassInfo.Key] )\r\n\t\t\t{\r\n\t\t\t\ttarget[KnockoutDecoratorClassInfo.Key] = new this();\r\n\t\t\t}\r\n\t\t\treturn target[KnockoutDecoratorClassInfo.Key];\r\n\t\t}\r\n\r\n\t\tpublic pushIgnoreProperty( property: string ): void\r\n\t\t{\r\n\t\t\tif ( !this.ignoreProperties ) this.ignoreProperties = [];\r\n\t\t\tthis.ignoreProperties.push( property );\r\n\t\t}\r\n\t\tpublic isIgnoreProperty( property: string ): boolean\r\n\t\t{\r\n\t\t\treturn this.ignoreProperties &&\r\n\t\t\t\tthis.ignoreProperties.indexOf( property ) != -1;\r\n\t\t}\r\n\r\n\t\tpublic pushKoExtend( name: string, extendOptions: any ): void\r\n\t\t{\r\n\t\t\tif ( !this.extendsHash ) this.extendsHash = {};\r\n\t\t\tif ( !this.extendsHash[name] ) this.extendsHash[name] = [];\r\n\t\t\tthis.extendsHash[name].push( extendOptions );\r\n\t\t}\r\n\r\n\t\tpublic applyKoExtend( target: string, o: KnockoutObservable<any> ): void\r\n\t\t{\r\n\t\t\tif ( !this.extendsHash ) return;\r\n\t\t\tlet extendArr = this.extendsHash[target];\r\n\t\t\tif ( !extendArr ) return;\r\n\t\t\tlet len = extendArr.length;\r\n\t\t\tfor ( let i = 0; i < len; ++i )\r\n\t\t\t{\r\n\t\t\t\to.extend( extendArr[i] );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic pushSetFilter( property: string, filterFunc: ( v: any ) => any )\r\n\t\t{\r\n\t\t\tif ( !this.setFiltersHash ) this.setFiltersHash = {};\r\n\t\t\tlet filters = this.setFiltersHash[property]\r\n\t\t\tif ( !filters )\r\n\t\t\t{\r\n\t\t\t\tfilters = this.setFiltersHash[property] = [];\r\n\t\t\t}\r\n\t\t\tfilters.push( filterFunc );\r\n\t\t}\r\n\r\n\t\tpublic getSetter( target: string, o: KnockoutObservable<any> ): any\r\n\t\t{\r\n\t\t\tif ( !this.setFiltersHash ) return o;\r\n\t\t\tlet filters = this.setFiltersHash[target];\r\n\t\t\tif ( !filters ) return o;\r\n\t\t\tlet len = filters.length;\r\n\t\t\treturn ( v: any ) =>\r\n\t\t\t{\r\n\t\t\t\tfor ( let i = 0; i < len; ++i )\r\n\t\t\t\t{\r\n\t\t\t\t\tv = filters[i]( v );\r\n\t\t\t\t}\r\n\t\t\t\to( v );\r\n\t\t\t}\r\n\t\t}\r\n\r\n\t\tpublic static readonly Key = \"__vtKnockoutDecoratorClassInfo__\";\r\n\t\tprivate ignoreProperties: string[];\r\n\t\tprivate extendsHash: { [property: string]: any[] };\r\n\t\tprivate setFiltersHash: { [property: string]: ( ( v: any ) => any )[] }\r\n\r\n\t\tprivate constructor() { }\r\n\t}\r\n\r\n\t// Information that instanced object should have.\r\n\tclass KnockoutDecoratorObjInfo\r\n\t{\r\n\t\tpublic static Get( target: any ): KnockoutDecoratorObjInfo\r\n\t\t{\r\n\t\t\tif ( !target[KnockoutDecoratorObjInfo.Key] )\r\n\t\t\t{\r\n\t\t\t\ttarget[KnockoutDecoratorObjInfo.Key] = new this( target );\r\n\t\t\t}\r\n\t\t\treturn target[KnockoutDecoratorObjInfo.Key];\r\n\t\t}\r\n\r\n\t\tpublic makeObservable( property: string ): void\r\n\t\t{\r\n\t\t\tlet o = ko.observable<any>();\r\n\t\t\tthis.koObservableHash[property] = o;\r\n\t\t\tlet prototype = Object.getPrototypeOf( this.target )\r\n\t\t\tlet classInfo = KnockoutDecoratorClassInfo.Get( prototype );\r\n\t\t\tclassInfo.applyKoExtend( property, o ); KnockoutDecoratorClassInfo.Get( prototype )\r\n\t\t\tObject.defineProperty( this.target, property, {\r\n\t\t\t\tget: () =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlastGetKoObservable = o;\r\n\t\t\t\t\treturn o();\r\n\t\t\t\t},\r\n\t\t\t\tset: classInfo.getSetter( property, o )\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\tpublic makeObservableArray( property: string ): void\r\n\t\t{\r\n\t\t\tfunction replaceFunction( src: any[], o: KnockoutObservableArray<any> )\r\n\t\t\t{\r\n\t\t\t\tlet originals: { [fn: string]: Function } = {};\r\n\t\t\t\t[\"splice\", \"pop\", \"push\", \"shift\", \"unshift\", \"reverse\", \"sort\"].forEach( fnName =>\r\n\t\t\t\t{\r\n\t\t\t\t\toriginals[fnName] = ( <any>src )[fnName];\r\n\t\t\t\t\tlet mimicry = function ()\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t// restore the original function for call it inside ObservableArray.\r\n\t\t\t\t\t\t( <any>src )[fnName] = originals[fnName];\r\n\r\n\t\t\t\t\t\t// call ObservableArray function\r\n\t\t\t\t\t\tlet res = ( o[fnName] as Function ).apply( o, arguments );\r\n\r\n\t\t\t\t\t\t// rewrite the original function again.\r\n\t\t\t\t\t\t( <any>src )[fnName] = mimicry;\r\n\r\n\t\t\t\t\t\treturn res;\r\n\t\t\t\t\t};\r\n\r\n\t\t\t\t\t// rewrite the original function\r\n\t\t\t\t\t( <any>src )[fnName] = mimicry;\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\t\t\tfunction mergeFunction( src: any[], o: KnockoutObservableArray<any> )\r\n\t\t\t{\r\n\t\t\t\t[\"replace\", \"remove\", \"removeAll\", \"destroy\", \"destroyAll\"].forEach( fnName =>\r\n\t\t\t\t{\r\n\t\t\t\t\t( <any>src )[fnName] = function ()\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn ( o[fnName] as Function ).apply( o, arguments );\r\n\t\t\t\t\t};\r\n\t\t\t\t} );\r\n\t\t\t}\r\n\r\n\t\t\tlet o = ko.observableArray<any>();\r\n\t\t\tthis.koObservableArrayHash[property] = o;\r\n\t\t\tlet prototype = Object.getPrototypeOf( this.target )\r\n\t\t\tlet classInfo = KnockoutDecoratorClassInfo.Get( prototype );\r\n\t\t\tclassInfo.applyKoExtend( property, o ); KnockoutDecoratorClassInfo.Get( prototype )\r\n\r\n\t\t\tObject.defineProperty( this.target, property, {\r\n\t\t\t\tget: () =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlastGetKoObservableArray = o;\r\n\t\t\t\t\treturn o();\r\n\t\t\t\t},\r\n\t\t\t\tset: function ( arrayValue: any[] )\r\n\t\t\t\t{\r\n\t\t\t\t\tif ( arrayValue )\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treplaceFunction( arrayValue, o );\r\n\t\t\t\t\t\tmergeFunction( arrayValue, o );\r\n\t\t\t\t\t}\r\n\t\t\t\t\tclassInfo.getSetter( property, o )( arrayValue );\r\n\t\t\t\t}\r\n\t\t\t} );\r\n\r\n\t\t}\r\n\r\n\t\tpublic makeComputed( accessor: string, getter: () => any, setter: ( v: any ) => void, options: IComputedOptions ): void\r\n\t\t{\r\n\t\t\tlet computedOptions: KnockoutComputedDefine<any> = {\r\n\t\t\t\tread: getter,\r\n\t\t\t\twrite: setter,\r\n\t\t\t\towner: this.target\r\n\t\t\t};\r\n\t\t\tif ( options )\r\n\t\t\t{\r\n\t\t\t\tfor ( let key in options )\r\n\t\t\t\t{\r\n\t\t\t\t\t( <any>computedOptions )[key] = ( <any>options )[key];\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tlet c = ko.computed( computedOptions );\r\n\t\t\tthis.koComputedHash[accessor] = c;\r\n\t\t\tlet prototype = Object.getPrototypeOf( this.target )\r\n\t\t\tlet classInfo = KnockoutDecoratorClassInfo.Get( prototype );\r\n\t\t\tclassInfo.applyKoExtend( accessor, c );\r\n\t\t\tObject.defineProperty( this.target, accessor, {\r\n\t\t\t\tget:() =>\r\n\t\t\t\t{\r\n\t\t\t\t\tlastGetKoComputed = c;\r\n\t\t\t\t\treturn c();\r\n\t\t\t\t},\r\n\t\t\t\tset: setter ? classInfo.getSetter( accessor, c ) : undefined\r\n\t\t\t} );\r\n\t\t}\r\n\r\n\t\tpublic getObservable<T>( property: string ): KnockoutObservable<T>\r\n\t\t{\r\n\t\t\treturn this.koObservableHash[property];\r\n\t\t}\r\n\r\n\t\tpublic getObservableArray<T>( property: string ): KnockoutObservableArray<T>\r\n\t\t{\r\n\t\t\treturn this.koObservableArrayHash[property];\r\n\t\t}\r\n\r\n\t\tpublic getComputed<T>( accessor: string ): KnockoutComputed<T>\r\n\t\t{\r\n\t\t\treturn this.koComputedHash[accessor];\r\n\t\t}\r\n\r\n\t\tpublic static readonly Key = \"__vtKnockoutDecoratorObjInfo__\";\r\n\t\tprivate target: any;\r\n\t\tprivate koObservableHash: { [property: string]: KnockoutObservable<any> } = {};\r\n\t\tprivate koObservableArrayHash: { [property: string]: KnockoutObservableArray<any> } = {};\r\n\t\tprivate koComputedHash: { [accessor: string]: KnockoutComputed<any> } = {};\r\n\r\n\t\tprivate constructor( target: any )\r\n\t\t{\r\n\t\t\tthis.target = target;\r\n\t\t}\r\n\t}\r\n\t// #endregion\r\n\r\n\t// export default module\r\n\tif ( typeof exports !== typeof undefined )\r\n\t{\r\n\t\tmodule.exports = KnockoutDecorator;\r\n\t\tmodule.exports[\"default\"] = KnockoutDecorator;\r\n\t}\r\n}\r\n\r\nexport = KnockoutDecorator;\r\n"],"sourceRoot":"/source/"}