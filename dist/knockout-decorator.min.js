/*!
 * Knockout decorator
 * (c) vario
 * License: MIT (http://www.opensource.org/licenses/mit-license.php)
 */
(function (factory) {
    if ((window && window.require !== undefined) && typeof module === "object" && typeof module.exports === "object") {
        var v = factory(require, exports);
        if (v !== undefined) module.exports = v;
    }
    else if (typeof define === "function" && define.amd) {
        define(["require", "exports"], factory);
    }
	else {
		window["KnockoutDecorator"]=factory();
	}
})(function (require, exports) {
    "use strict";
    var KnockoutDecorator;
    (function (KnockoutDecorator) {
        function track(arg) {
            var options;
            if (typeof arg === "function") {
                options = {
                    pureComputed: true,
                    initializeMethod: null
                };
            }
            else {
                options = arg;
                var defaults = {
                    pureComputed: true,
                    initializeMethod: null
                };
                if (!options) {
                    options = defaults;
                }
                else {
                    for (var key in defaults) {
                        if (options[key] === undefined) {
                            options[key] = defaults[key];
                        }
                    }
                }
            }
            function classFactory(constructor) {
                var isIgnore = function (propertyName) {
                    if (!constructor[ignoresKey])
                        return false;
                    //console.log( "ig check", propertyName );
                    return constructor[ignoresKey].indexOf(propertyName) >= 0;
                };
                var trackConstructor = function () {
                    constructor.apply(this, arguments);
                    var o = this;
                    var properties = Object.keys(o);
                    properties.forEach(function (p) {
                        //console.log( "p is", p );
                        if (p === storeObservableKey)
                            return;
                        if (isIgnore(p))
                            return;
                        //console.log( "assign observable", p );
                        var v = o[p];
                        delete o[p];
                        if (Array.isArray(v)) {
                            observableArray(trackConstructor.prototype, p);
                        }
                        else {
                            observable(trackConstructor.prototype, p);
                        }
                        o[p] = v;
                    });
                    var functions = Object.keys(constructor.prototype);
                    //console.log( functions );
                    var computedAccessors = [];
                    functions.forEach(function (f) {
                        //console.log( "f is", f );
                        var d = Object.getOwnPropertyDescriptor(constructor.prototype, f);
                        if (!d || !d.get)
                            return;
                        if (isIgnore(f))
                            return;
                        var dummy = o[f];
                        if (getComputed(o, f))
                            return;
                        //console.log( "f is ", f, d.get );
                        //console.log( "f", f, f["name"] );
                        //return;
                        /*if ( isRegisteredObserbable( c.prototype, f ) )
                        {
                            computedAccessors.push( f );
                            return;
                        }*/
                        var factory = getComputedDecoratorFactory({
                            pure: options.pureComputed
                        });
                        factory(trackConstructor.prototype, f, d);
                        Object.defineProperty(trackConstructor.prototype, f, d);
                        computedAccessors.push(f);
                        //co = getComputed( o, f );
                        //console.log( "f is 2 ", dummy, co );
                    });
                    computedAccessors.forEach(function (a) { return o[a]; });
                    computedAccessors = null;
                    functions = null;
                    properties = null;
                    if (options.initializeMethod && typeof o[options.initializeMethod] === "function") {
                        o[options.initializeMethod]();
                    }
                };
                trackConstructor["prototype"] = constructor["prototype"];
                return trackConstructor;
            }
            if (typeof arg === "function") {
                return classFactory(arg);
            }
            else {
                return function (constructor) {
                    return classFactory(constructor);
                };
            }
        }
        KnockoutDecorator.track = track;
        /** @private */
        var ignoresKey = "__vtKnockoutIgnoresKey__";
        /**
         * Attach to a property or a accessor as decorator.
         * This decorator prevents a property or a accessor from converting to observable in @track.
         */
        function ignore(_class, propertyName) {
            var constructor = _class.constructor;
            if (!constructor[ignoresKey])
                constructor[ignoresKey] = [];
            constructor[ignoresKey].push(propertyName);
        }
        KnockoutDecorator.ignore = ignore;
        /**
         * Attach to a property as decorator.
         * If you change a property value, a view will also change. And vice versa.
         */
        function observable(_class, propertyName) {
            //if ( isRegisteredObserbable( _class, propertyName ) ) return;
            //setRegisterObserbable( _class, propertyName );
            function registerProperty(instancedObj) {
                var o = ko.observable();
                setObservableObjet(instancedObj, propertyName, o);
                assignExtendForInstancedObj(_class, instancedObj, propertyName);
                Object.defineProperty(instancedObj, propertyName, {
                    get: o,
                    set: getSetter(_class, propertyName, o)
                });
            }
            Object.defineProperty(_class, propertyName, {
                get: function () {
                    registerProperty(this);
                    return this[propertyName];
                },
                set: function (value) {
                    registerProperty(this);
                    this[propertyName] = value;
                }
            });
        }
        KnockoutDecorator.observable = observable;
        /**
         * Attach to a array property as decorator.
         * If you set a property to a new array data, a view will also change.
         * If you call a Array function such as push or pop, a view will also change.
         */
        function observableArray(_class, propertyName) {
            //if ( isRegisteredObserbable( _class, propertyName ) ) return;
            //setRegisterObserbable( _class, propertyName );
            function replaceFunction(src, o) {
                var originals = {};
                ["splice", "pop", "push", "shift", "unshift", "reverse", "sort"].forEach(function (fnName) {
                    originals[fnName] = src[fnName];
                    var mimicry = function () {
                        // restore the original function for call it inside ObservableArray.
                        src[fnName] = originals[fnName];
                        // call ObservableArray function
                        var res = o[fnName].apply(o, arguments);
                        // rewrite the original function again.
                        src[fnName] = mimicry;
                        return res;
                    };
                    // rewrite the original function
                    src[fnName] = mimicry;
                });
            }
            function mergeFunction(src, o) {
                ["replace", "remove", "removeAll", "destroy", "destroyAll"].forEach(function (fnName) {
                    src[fnName] = function () {
                        return o[fnName].apply(o, arguments);
                    };
                });
            }
            function registerProperty(instancedObj) {
                var o = ko.observableArray();
                setObservableObjet(instancedObj, propertyName, o);
                assignExtendForInstancedObj(_class, instancedObj, propertyName);
                Object.defineProperty(instancedObj, propertyName, {
                    get: o,
                    set: function (arrayValue) {
                        if (arrayValue) {
                            replaceFunction(arrayValue, o);
                            mergeFunction(arrayValue, o);
                        }
                        getSetter(_class, propertyName, o)(arrayValue);
                    }
                });
            }
            Object.defineProperty(_class, propertyName, {
                get: function () {
                    registerProperty(this);
                    return this[propertyName];
                },
                set: function (arrayValue) {
                    registerProperty(this);
                    this[propertyName] = arrayValue;
                }
            });
        }
        KnockoutDecorator.observableArray = observableArray;
        function computed() {
            if (arguments.length == 1) {
                return getComputedDecoratorFactory(arguments[0]);
            }
            getComputedDecoratorFactory(null).apply(this, arguments);
        }
        KnockoutDecorator.computed = computed;
        /**
         * Attach to a accessor as decorator.
         */
        function pureComputed(_class, propertyName, descriptor) {
            getComputedDecoratorFactory({ pure: true })(_class, propertyName, descriptor);
        }
        KnockoutDecorator.pureComputed = pureComputed;
        /**
         * Attach to a property or accessor.
         * @extend require attaching observable decorator.
         * @param options	Set parameter which define ko.extenders such as rateLimit.
         */
        function extend(options) {
            return function (_class, propertyName, descriptor) {
                registerExtend(_class, propertyName, options);
            };
        }
        KnockoutDecorator.extend = extend;
        //#region set filter decorators
        /**
         * Attach to a property or accessor(setter).
         * When you set a value to a property or a setter, the value will be changed through filters.
         * If there is more than one filter, filters are executed in the order from bottom to top.
         * @param filterFunc function that return a processed value.
         */
        function setFilter(filterFunc) {
            return function (_class, propertyName) {
                registerSetFilter(_class, propertyName, filterFunc);
            };
        }
        KnockoutDecorator.setFilter = setFilter;
        /**
         * Attach to a number type property or a accessor(setter).
         * This decorator is a kind of `@setFilter`.
         * This decorator converts to number type if set a value other than number type such as value is changed via input element on a browser.
         * If a converted value is NaN, it handles as zero.
         * @extend require attaching observable decorator.
         */
        function asNumber(_class, propertyName) {
            registerSetFilter(_class, propertyName, function (v) {
                if (!v || typeof v === "number")
                    return v;
                v = parseFloat(v);
                return isNaN(v) ? 0 : v;
            });
        }
        KnockoutDecorator.asNumber = asNumber;
        /**
         * Attach to a number type property or a accessor(setter).
         * This decorator is a kind of `@setFilter`.
         * This decorator keeps greater than or equal to minValue.
         * @extend require attaching observable decorator.
         */
        function min(minValue) {
            return setFilter(function (v) { return v < minValue ? minValue : v; });
        }
        KnockoutDecorator.min = min;
        /**
         * Attach to a number type property or a accessor(setter).
         * This decorator is a kind of `@setFilter`.
         * This decorator keeps less than or equal to maxValue.
         * @extend require attaching observable decorator.
         */
        function max(maxValue) {
            return setFilter(function (v) { return v > maxValue ? maxValue : v; });
        }
        KnockoutDecorator.max = max;
        /**
         * Attach to a number type property or a accessor(setter).
         * This decorator is a kind of `@setFilter`.
         * This decorator keeps between minValue and maxValue inclusive.
         * @extend require attaching observable decorator.
         */
        function clamp(minValue, maxValue) {
            if (minValue > maxValue) {
                var tmp = minValue;
                minValue = maxValue;
                maxValue = tmp;
            }
            return setFilter(function (v) {
                if (v < minValue)
                    v = minValue;
                else if (v > maxValue)
                    v = maxValue;
                return v;
            });
        }
        KnockoutDecorator.clamp = clamp;
        //#endregion
        /**
         * Get raw knockout observable object.
         * @param instancedObj	Instanced object.
         * @param propertyName		Name of a property which is attached the @observable.
         * @return If found then KnockoutObservable object, else null.
         */
        function getObservable(instancedObj, propertyName) {
            var o = getObservableObject(instancedObj, propertyName);
            return (ko.isObservable(o) && o.indexOf === undefined) ? o : null;
        }
        KnockoutDecorator.getObservable = getObservable;
        /**
         * Get row knockout observable array object.
         * @param instancedObj	Instanced object.
         * @param propertyName		Name of a property which is attached the @observableArray.
         */
        function getObservableArray(instancedObj, propertyName) {
            var o = getObservableObject(instancedObj, propertyName);
            var res = (ko.isObservable(o) && o.indexOf !== undefined) ? o : null;
            return res;
        }
        KnockoutDecorator.getObservableArray = getObservableArray;
        /**
         * Get raw knockout computed object.
         * @param instancedObj	Instanced object.
         * @param propertyName		Name of a property which is attached the @computed.
         * @return If found then KnockoutComputed object, else null.
         */
        function getComputed(instancedObj, propertyName) {
            var c = getObservableObject(instancedObj, propertyName);
            return ko.isComputed(c) ? c : null;
        }
        KnockoutDecorator.getComputed = getComputed;
        // #region no export
        /** @private */
        var storeObservableKey = "__vtKnockoutObservables__";
        /** @private */
        function setObservableObjet(instancedObj, propertyName, o) {
            if (!instancedObj[storeObservableKey])
                instancedObj[storeObservableKey] = {};
            instancedObj[storeObservableKey][propertyName] = o;
        }
        /** @private */
        function getObservableObject(instancedObj, propertyName) {
            var store = instancedObj[storeObservableKey];
            if (!store)
                return null;
            return store[propertyName];
        }
        /** @private */
        function getComputedDecoratorFactory(options) {
            return function (_class, propertyName, descriptor) {
                //if ( isRegisteredObserbable( _class, propertyName ) ) return;
                //setRegisterObserbable( _class, propertyName );
                var getter = descriptor.get;
                if (!getter) {
                    throw "@Computed and @pureComputed require getter.";
                }
                var setter = descriptor.set;
                function registerProperty(instancedObj) {
                    //console.log( "register property computed", instancedObj, propertyName );
                    var computedOptions = {
                        read: getter,
                        write: setter,
                        owner: instancedObj
                    };
                    if (options) {
                        var _loop_1 = function (key) {
                            if (typeof options[key] === "function") {
                                var fn_1 = options[key];
                                options[key] = function () {
                                    fn_1.apply(instancedObj, arguments);
                                };
                            }
                            computedOptions[key] = options[key];
                        };
                        for (var key in options) {
                            _loop_1(key);
                        }
                    }
                    var c = ko.computed(computedOptions);
                    setObservableObjet(instancedObj, propertyName, c);
                    assignExtendForInstancedObj(_class, instancedObj, propertyName);
                    Object.defineProperty(instancedObj, propertyName, {
                        get: c,
                        set: setter ? getSetter(_class, propertyName, c) : undefined
                    });
                }
                descriptor.get = function () {
                    registerProperty(this);
                    return this[propertyName];
                };
                if (setter) {
                    descriptor.set = function (value) {
                        registerProperty(this);
                        this[propertyName] = value;
                    };
                }
            };
        }
        /** @private */
        //const registerObjserbablesKey = "__vtKnockoutRegisterObserbables__";
        /** @private */
        /*function isRegisteredObserbable( _class: any, propertyName: string ): boolean
        {
            return _class[registerObjserbablesKey] && _class[registerObjserbablesKey].indexOf( propertyName ) >= 0
        }*/
        /** @private */
        /*function setRegisterObserbable( _class: any, propertyName: string ): void
        {
            if ( !_class[registerObjserbablesKey] )
            {
                _class[registerObjserbablesKey] = [];
            }
            _class[registerObjserbablesKey].push( propertyName );
        }*/
        /** @private */
        var storeExtendKey = "__vtKnockoutExtends__";
        /** @private */
        function registerExtend(_class, propertyName, extendOptions) {
            if (!_class[storeExtendKey])
                _class[storeExtendKey] = {};
            _class[storeExtendKey][propertyName] = extendOptions;
        }
        /** @private */
        function getExtend(_class, propertyName) {
            var store = _class[storeExtendKey];
            if (!store)
                return null;
            return store[propertyName];
        }
        /** @private */
        var storeSetFilterKey = "__vtKnockoutSetFilters__";
        /** @private */
        function registerSetFilter(_class, propertyName, filterFunc) {
            if (!_class[storeSetFilterKey])
                _class[storeSetFilterKey] = {};
            if (!_class[storeSetFilterKey][propertyName])
                _class[storeSetFilterKey][propertyName] = [];
            _class[storeSetFilterKey][propertyName].push(filterFunc);
        }
        /** @private */
        function getSetter(_class, propertyName, observable) {
            if (!_class[storeSetFilterKey])
                return observable;
            var filters = _class[storeSetFilterKey][propertyName];
            if (!filters)
                return observable;
            var len = filters.length;
            return function (v) {
                var original = v;
                for (var i = 0; i < len; ++i) {
                    v = filters[i](v);
                }
                observable(v);
            };
        }
        /** @private */
        function assignExtendForInstancedObj(_class, instancedObj, propertyName) {
            var o = getObservableObject(instancedObj, propertyName);
            var ext = getExtend(_class, propertyName);
            if (ext)
                o.extend(ext);
        }
        // #endregion
        if (typeof exports !== typeof undefined) {
            module.exports = KnockoutDecorator;
            module.exports["default"] = KnockoutDecorator;
        }
    })(KnockoutDecorator || (KnockoutDecorator = {}));
    return KnockoutDecorator;
});
